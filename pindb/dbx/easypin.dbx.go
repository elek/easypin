//lint:file-ignore U1000,ST1012 generated file
// AUTOGENERATED BY storj.io/dbx
// DO NOT EDIT.

package dbx

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/jackc/pgconn"
	_ "github.com/jackc/pgx/v4/stdlib"

	"storj.io/private/tagsql"
)

// Prevent conditional imports from causing build failures.
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr     = func(err *Error) error { return err }
	Logger      func(format string, args ...interface{})
	ShouldRetry func(driver string, err error) bool

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...interface{}) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	e := &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func shouldRetry(driver string, err error) bool {
	if ShouldRetry == nil {
		return false
	}
	return ShouldRetry(driver, err)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...interface{}) (tagsql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
}

var (
	notAPointer     = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	tagsql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}

	driver string
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "pgx":
		sql_db, err = openpgx(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

		db = &DB{
		DB: tagsql.Wrap(sql_db),

		driver: driver,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "pgx":
		db.dbMethods = newpgx(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func (obj *DB) NewRx() *Rx {
	return &Rx{db: obj}
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx tagsql.Tx
	txMethods
}

type dialectTx struct {
	tx tagsql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type pgxImpl struct {
	db      *DB
	dialect __sqlbundle_pgx
	driver  driver
	txn     bool
}

func (obj *pgxImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *pgxImpl) logStmt(stmt string, args ...interface{}) {
	pgxLogStmt(stmt, args...)
}

func (obj *pgxImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

func (obj *pgxImpl) shouldRetry(err error) bool {
	return !obj.txn && shouldRetry(obj.db.driver, err)
}

type pgxImpl_retryingRow struct {
	obj   *pgxImpl
	ctx   context.Context
	query string
	args  []interface{}
}

func (obj *pgxImpl) queryRowContext(ctx context.Context, query string, args ...interface{}) *pgxImpl_retryingRow {
	return &pgxImpl_retryingRow{
		obj:   obj,
		ctx:   ctx,
		query: query,
		args:  args,
	}
}

func (rows *pgxImpl_retryingRow) Scan(dest ...interface{}) error {
	for {
		err := rows.obj.driver.QueryRowContext(rows.ctx, rows.query, rows.args...).Scan(dest...)
		if err != nil {
			if rows.obj.shouldRetry(err) {
				continue
			}
			// caller will wrap this error
			return err
		}
		return nil
	}
}

type pgxDB struct {
	db *DB
	*pgxImpl
}

func newpgx(db *DB) *pgxDB {
	return &pgxDB{
		db: db,
		pgxImpl: &pgxImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *pgxDB) Schema() string {
	return `CREATE TABLE nodes (
	cid text NOT NULL,
	expired_at timestamp with time zone NOT NULL,
	amount bigint NOT NULL,
	created_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
	PRIMARY KEY ( cid )
);
CREATE TABLE pins (
	tx text NOT NULL,
	ix integer NOT NULL,
	cid text NOT NULL,
	retry integer NOT NULL DEFAULT 0,
	error text NOT NULL DEFAULT '',
	parse boolean NOT NULL DEFAULT false,
	amount bigint NOT NULL,
	created_at timestamp with time zone NOT NULL DEFAULT current_timestamp,
	PRIMARY KEY ( tx, ix )
);`
}

func (obj *pgxDB) wrapTx(tx tagsql.Tx) txMethods {
	return &pgxTx{
		dialectTx: dialectTx{tx: tx},
		pgxImpl: &pgxImpl{
			db:     obj.db,
			driver: tx,
			txn:    true,
		},
	}
}

type pgxTx struct {
	dialectTx
	*pgxImpl
}

func pgxLogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []interface{}

func (p pretty) Format(f fmt.State, c rune) {
	fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			fmt.Fprintf(f, "%q", v)
		case time.Time:
			fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			fmt.Fprintf(f, "%q", v)
		default:
			fmt.Fprintf(f, "%v", v)
		}
	}
	fmt.Fprint(f, "]")
}

type Node struct {
	Cid       string
	ExpiredAt time.Time
	Amount    int64
	CreatedAt time.Time
}

func (Node) _Table() string { return "nodes" }

type Node_Update_Fields struct {
	ExpiredAt Node_ExpiredAt_Field
}

type Node_Cid_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Cid(v string) Node_Cid_Field {
	return Node_Cid_Field{_set: true, _value: v}
}

func (f Node_Cid_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Cid_Field) _Column() string { return "cid" }

type Node_ExpiredAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_ExpiredAt(v time.Time) Node_ExpiredAt_Field {
	return Node_ExpiredAt_Field{_set: true, _value: v}
}

func (f Node_ExpiredAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_ExpiredAt_Field) _Column() string { return "expired_at" }

type Node_Amount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_Amount(v int64) Node_Amount_Field {
	return Node_Amount_Field{_set: true, _value: v}
}

func (f Node_Amount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Amount_Field) _Column() string { return "amount" }

type Node_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_CreatedAt(v time.Time) Node_CreatedAt_Field {
	return Node_CreatedAt_Field{_set: true, _value: v}
}

func (f Node_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_CreatedAt_Field) _Column() string { return "created_at" }

type Pin struct {
	Tx        string
	Ix        int
	Cid       string
	Retry     int
	Error     string
	Parse     bool
	Amount    int64
	CreatedAt time.Time
}

func (Pin) _Table() string { return "pins" }

type Pin_Create_Fields struct {
	Retry Pin_Retry_Field
	Error Pin_Error_Field
	Parse Pin_Parse_Field
}

type Pin_Update_Fields struct {
	Retry Pin_Retry_Field
	Error Pin_Error_Field
}

type Pin_Tx_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Pin_Tx(v string) Pin_Tx_Field {
	return Pin_Tx_Field{_set: true, _value: v}
}

func (f Pin_Tx_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_Tx_Field) _Column() string { return "tx" }

type Pin_Ix_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Pin_Ix(v int) Pin_Ix_Field {
	return Pin_Ix_Field{_set: true, _value: v}
}

func (f Pin_Ix_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_Ix_Field) _Column() string { return "ix" }

type Pin_Cid_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Pin_Cid(v string) Pin_Cid_Field {
	return Pin_Cid_Field{_set: true, _value: v}
}

func (f Pin_Cid_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_Cid_Field) _Column() string { return "cid" }

type Pin_Retry_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Pin_Retry(v int) Pin_Retry_Field {
	return Pin_Retry_Field{_set: true, _value: v}
}

func (f Pin_Retry_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_Retry_Field) _Column() string { return "retry" }

type Pin_Error_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Pin_Error(v string) Pin_Error_Field {
	return Pin_Error_Field{_set: true, _value: v}
}

func (f Pin_Error_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_Error_Field) _Column() string { return "error" }

type Pin_Parse_Field struct {
	_set   bool
	_null  bool
	_value bool
}

func Pin_Parse(v bool) Pin_Parse_Field {
	return Pin_Parse_Field{_set: true, _value: v}
}

func (f Pin_Parse_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_Parse_Field) _Column() string { return "parse" }

type Pin_Amount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Pin_Amount(v int64) Pin_Amount_Field {
	return Pin_Amount_Field{_set: true, _value: v}
}

func (f Pin_Amount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_Amount_Field) _Column() string { return "amount" }

type Pin_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Pin_CreatedAt(v time.Time) Pin_CreatedAt_Field {
	return Pin_CreatedAt_Field{_set: true, _value: v}
}

func (f Pin_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Pin_CreatedAt_Field) _Column() string { return "created_at" }

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_cockroach struct{}

func (p __sqlbundle_cockroach) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgx struct{}

func (p __sqlbundle_pgx) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_pgxcockroach struct{}

func (p __sqlbundle_pgxcockroach) Rebind(sql string) string {
	type sqlParseState int
	const (
		sqlParseStart sqlParseState = iota
		sqlParseInStringLiteral
		sqlParseInQuotedIdentifier
		sqlParseInComment
	)

	out := make([]byte, 0, len(sql)+10)

	j := 1
	state := sqlParseStart
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		switch state {
		case sqlParseStart:
			switch ch {
			case '?':
				out = append(out, '$')
				out = append(out, strconv.Itoa(j)...)
				state = sqlParseStart
				j++
				continue
			case '-':
				if i+1 < len(sql) && sql[i+1] == '-' {
					state = sqlParseInComment
				}
			case '"':
				state = sqlParseInQuotedIdentifier
			case '\'':
				state = sqlParseInStringLiteral
			}
		case sqlParseInStringLiteral:
			if ch == '\'' {
				state = sqlParseStart
			}
		case sqlParseInQuotedIdentifier:
			if ch == '"' {
				state = sqlParseStart
			}
		case sqlParseInComment:
			if ch == '\n' {
				state = sqlParseStart
			}
		}
		out = append(out, ch)
	}

	return string(out)
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime or possibly embed time
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string {
	if h.SQL == nil {
		return ""
	}
	return h.SQL.Render()
}

//
// end runtime support for building sql statements
//

func (obj *pgxImpl) Create_Pin(ctx context.Context,
	pin_tx Pin_Tx_Field,
	pin_ix Pin_Ix_Field,
	pin_cid Pin_Cid_Field,
	pin_amount Pin_Amount_Field,
	optional Pin_Create_Fields) (
	pin *Pin, err error) {
	defer mon.Task()(&ctx)(&err)
	__tx_val := pin_tx.value()
	__ix_val := pin_ix.value()
	__cid_val := pin_cid.value()
	__amount_val := pin_amount.value()

	var __columns = &__sqlbundle_Hole{SQL: __sqlbundle_Literal("tx, ix, cid, amount")}
	var __placeholders = &__sqlbundle_Hole{SQL: __sqlbundle_Literal("?, ?, ?, ?")}
	var __clause = &__sqlbundle_Hole{SQL: __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("("), __columns, __sqlbundle_Literal(") VALUES ("), __placeholders, __sqlbundle_Literal(")")}}}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("INSERT INTO pins "), __clause, __sqlbundle_Literal(" RETURNING pins.tx, pins.ix, pins.cid, pins.retry, pins.error, pins.parse, pins.amount, pins.created_at")}}

	var __values []interface{}
	__values = append(__values, __tx_val, __ix_val, __cid_val, __amount_val)

	__optional_columns := __sqlbundle_Literals{Join: ", "}
	__optional_placeholders := __sqlbundle_Literals{Join: ", "}

	if optional.Retry._set {
		__values = append(__values, optional.Retry.value())
		__optional_columns.SQLs = append(__optional_columns.SQLs, __sqlbundle_Literal("retry"))
		__optional_placeholders.SQLs = append(__optional_placeholders.SQLs, __sqlbundle_Literal("?"))
	}

	if optional.Error._set {
		__values = append(__values, optional.Error.value())
		__optional_columns.SQLs = append(__optional_columns.SQLs, __sqlbundle_Literal("error"))
		__optional_placeholders.SQLs = append(__optional_placeholders.SQLs, __sqlbundle_Literal("?"))
	}

	if optional.Parse._set {
		__values = append(__values, optional.Parse.value())
		__optional_columns.SQLs = append(__optional_columns.SQLs, __sqlbundle_Literal("parse"))
		__optional_placeholders.SQLs = append(__optional_placeholders.SQLs, __sqlbundle_Literal("?"))
	}

	if len(__optional_columns.SQLs) == 0 {
		if __columns.SQL == nil {
			__clause.SQL = __sqlbundle_Literal("DEFAULT VALUES")
		}
	} else {
		__columns.SQL = __sqlbundle_Literals{Join: ", ", SQLs: []__sqlbundle_SQL{__columns.SQL, __optional_columns}}
		__placeholders.SQL = __sqlbundle_Literals{Join: ", ", SQLs: []__sqlbundle_SQL{__placeholders.SQL, __optional_placeholders}}
	}
	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	pin = &Pin{}
	err = obj.queryRowContext(ctx, __stmt, __values...).Scan(&pin.Tx, &pin.Ix, &pin.Cid, &pin.Retry, &pin.Error, &pin.Parse, &pin.Amount, &pin.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pin, nil

}

func (obj *pgxImpl) Create_Node(ctx context.Context,
	node_cid Node_Cid_Field,
	node_expired_at Node_ExpiredAt_Field,
	node_amount Node_Amount_Field) (
	node *Node, err error) {
	defer mon.Task()(&ctx)(&err)
	__cid_val := node_cid.value()
	__expired_at_val := node_expired_at.value()
	__amount_val := node_amount.value()

	var __columns = &__sqlbundle_Hole{SQL: __sqlbundle_Literal("cid, expired_at, amount")}
	var __placeholders = &__sqlbundle_Hole{SQL: __sqlbundle_Literal("?, ?, ?")}
	var __clause = &__sqlbundle_Hole{SQL: __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("("), __columns, __sqlbundle_Literal(") VALUES ("), __placeholders, __sqlbundle_Literal(")")}}}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("INSERT INTO nodes "), __clause, __sqlbundle_Literal(" RETURNING nodes.cid, nodes.expired_at, nodes.amount, nodes.created_at")}}

	var __values []interface{}
	__values = append(__values, __cid_val, __expired_at_val, __amount_val)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.queryRowContext(ctx, __stmt, __values...).Scan(&node.Cid, &node.ExpiredAt, &node.Amount, &node.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *pgxImpl) Get_Pin_By_Cid(ctx context.Context,
	pin_cid Pin_Cid_Field) (
	pin *Pin, err error) {
	defer mon.Task()(&ctx)(&err)

	var __embed_stmt = __sqlbundle_Literal("SELECT pins.tx, pins.ix, pins.cid, pins.retry, pins.error, pins.parse, pins.amount, pins.created_at FROM pins WHERE pins.cid = ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, pin_cid.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	for {
		pin, err = func() (pin *Pin, err error) {
			__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
			if err != nil {
				return nil, err
			}
			defer __rows.Close()

			if !__rows.Next() {
				if err := __rows.Err(); err != nil {
					return nil, err
				}
				return nil, sql.ErrNoRows
			}

			pin = &Pin{}
			err = __rows.Scan(&pin.Tx, &pin.Ix, &pin.Cid, &pin.Retry, &pin.Error, &pin.Parse, &pin.Amount, &pin.CreatedAt)
			if err != nil {
				return nil, err
			}

			if __rows.Next() {
				return nil, errTooManyRows
			}

			if err := __rows.Err(); err != nil {
				return nil, err
			}

			return pin, nil
		}()
		if err != nil {
			if obj.shouldRetry(err) {
				continue
			}
			if err == errTooManyRows {
				return nil, tooManyRows("Pin_By_Cid")
			}
			return nil, obj.makeErr(err)
		}
		return pin, nil
	}

}

func (obj *pgxImpl) All_Pin_OrderBy_Desc_CreatedAt(ctx context.Context) (
	rows []*Pin, err error) {
	defer mon.Task()(&ctx)(&err)

	var __embed_stmt = __sqlbundle_Literal("SELECT pins.tx, pins.ix, pins.cid, pins.retry, pins.error, pins.parse, pins.amount, pins.created_at FROM pins ORDER BY pins.created_at DESC")

	var __values []interface{}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	for {
		rows, err = func() (rows []*Pin, err error) {
			__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
			if err != nil {
				return nil, err
			}
			defer __rows.Close()

			for __rows.Next() {
				pin := &Pin{}
				err = __rows.Scan(&pin.Tx, &pin.Ix, &pin.Cid, &pin.Retry, &pin.Error, &pin.Parse, &pin.Amount, &pin.CreatedAt)
				if err != nil {
					return nil, err
				}
				rows = append(rows, pin)
			}
			if err := __rows.Err(); err != nil {
				return nil, err
			}
			return rows, nil
		}()
		if err != nil {
			if obj.shouldRetry(err) {
				continue
			}
			return nil, obj.makeErr(err)
		}
		return rows, nil
	}

}

func (obj *pgxImpl) All_Pin_By_Cid_OrderBy_Desc_CreatedAt(ctx context.Context,
	pin_cid Pin_Cid_Field) (
	rows []*Pin, err error) {
	defer mon.Task()(&ctx)(&err)

	var __embed_stmt = __sqlbundle_Literal("SELECT pins.tx, pins.ix, pins.cid, pins.retry, pins.error, pins.parse, pins.amount, pins.created_at FROM pins WHERE pins.cid = ? ORDER BY pins.created_at DESC")

	var __values []interface{}
	__values = append(__values, pin_cid.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	for {
		rows, err = func() (rows []*Pin, err error) {
			__rows, err := obj.driver.QueryContext(ctx, __stmt, __values...)
			if err != nil {
				return nil, err
			}
			defer __rows.Close()

			for __rows.Next() {
				pin := &Pin{}
				err = __rows.Scan(&pin.Tx, &pin.Ix, &pin.Cid, &pin.Retry, &pin.Error, &pin.Parse, &pin.Amount, &pin.CreatedAt)
				if err != nil {
					return nil, err
				}
				rows = append(rows, pin)
			}
			if err := __rows.Err(); err != nil {
				return nil, err
			}
			return rows, nil
		}()
		if err != nil {
			if obj.shouldRetry(err) {
				continue
			}
			return nil, obj.makeErr(err)
		}
		return rows, nil
	}

}

func (obj *pgxImpl) Update_Pin_By_Tx_And_Ix(ctx context.Context,
	pin_tx Pin_Tx_Field,
	pin_ix Pin_Ix_Field,
	update Pin_Update_Fields) (
	pin *Pin, err error) {
	defer mon.Task()(&ctx)(&err)
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE pins SET "), __sets, __sqlbundle_Literal(" WHERE pins.tx = ? AND pins.ix = ? RETURNING pins.tx, pins.ix, pins.cid, pins.retry, pins.error, pins.parse, pins.amount, pins.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Retry._set {
		__values = append(__values, update.Retry.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("retry = ?"))
	}

	if update.Error._set {
		__values = append(__values, update.Error.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("error = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, pin_tx.value(), pin_ix.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	pin = &Pin{}
	err = obj.queryRowContext(ctx, __stmt, __values...).Scan(&pin.Tx, &pin.Ix, &pin.Cid, &pin.Retry, &pin.Error, &pin.Parse, &pin.Amount, &pin.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return pin, nil
}

func (obj *pgxImpl) Update_Node_By_Cid(ctx context.Context,
	node_cid Node_Cid_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	defer mon.Task()(&ctx)(&err)
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE nodes SET "), __sets, __sqlbundle_Literal(" WHERE nodes.cid = ? RETURNING nodes.cid, nodes.expired_at, nodes.amount, nodes.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.ExpiredAt._set {
		__values = append(__values, update.ExpiredAt.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("expired_at = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, node_cid.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.queryRowContext(ctx, __stmt, __values...).Scan(&node.Cid, &node.ExpiredAt, &node.Amount, &node.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil
}

func (impl pgxImpl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(*pgconn.PgError); ok {
		if e.Code[:2] == "23" {
			return e.ConstraintName, true
		}
	}
	return "", false
}

func (obj *pgxImpl) deleteAll(ctx context.Context) (count int64, err error) {
	defer mon.Task()(&ctx)(&err)
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM pins;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.ExecContext(ctx, "DELETE FROM nodes;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Rx struct {
	db *DB
	tx *Tx
}

func (rx *Rx) UnsafeTx(ctx context.Context) (unsafe_tx tagsql.Tx, err error) {
	tx, err := rx.getTx(ctx)
	if err != nil {
		return nil, err
	}
	return tx.Tx, nil
}

func (rx *Rx) getTx(ctx context.Context) (tx *Tx, err error) {
	if rx.tx == nil {
		if rx.tx, err = rx.db.Open(ctx); err != nil {
			return nil, err
		}
	}
	return rx.tx, nil
}

func (rx *Rx) Rebind(s string) string {
	return rx.db.Rebind(s)
}

func (rx *Rx) Commit() (err error) {
	if rx.tx != nil {
		err = rx.tx.Commit()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) Rollback() (err error) {
	if rx.tx != nil {
		err = rx.tx.Rollback()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) All_Pin_By_Cid_OrderBy_Desc_CreatedAt(ctx context.Context,
	pin_cid Pin_Cid_Field) (
	rows []*Pin, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Pin_By_Cid_OrderBy_Desc_CreatedAt(ctx, pin_cid)
}

func (rx *Rx) All_Pin_OrderBy_Desc_CreatedAt(ctx context.Context) (
	rows []*Pin, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Pin_OrderBy_Desc_CreatedAt(ctx)
}

func (rx *Rx) Create_Node(ctx context.Context,
	node_cid Node_Cid_Field,
	node_expired_at Node_ExpiredAt_Field,
	node_amount Node_Amount_Field) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Node(ctx, node_cid, node_expired_at, node_amount)

}

func (rx *Rx) Create_Pin(ctx context.Context,
	pin_tx Pin_Tx_Field,
	pin_ix Pin_Ix_Field,
	pin_cid Pin_Cid_Field,
	pin_amount Pin_Amount_Field,
	optional Pin_Create_Fields) (
	pin *Pin, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Pin(ctx, pin_tx, pin_ix, pin_cid, pin_amount, optional)

}

func (rx *Rx) Get_Pin_By_Cid(ctx context.Context,
	pin_cid Pin_Cid_Field) (
	pin *Pin, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Pin_By_Cid(ctx, pin_cid)
}

func (rx *Rx) Update_Node_By_Cid(ctx context.Context,
	node_cid Node_Cid_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Node_By_Cid(ctx, node_cid, update)
}

func (rx *Rx) Update_Pin_By_Tx_And_Ix(ctx context.Context,
	pin_tx Pin_Tx_Field,
	pin_ix Pin_Ix_Field,
	update Pin_Update_Fields) (
	pin *Pin, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Pin_By_Tx_And_Ix(ctx, pin_tx, pin_ix, update)
}

type Methods interface {
	All_Pin_By_Cid_OrderBy_Desc_CreatedAt(ctx context.Context,
		pin_cid Pin_Cid_Field) (
		rows []*Pin, err error)

	All_Pin_OrderBy_Desc_CreatedAt(ctx context.Context) (
		rows []*Pin, err error)

	Create_Node(ctx context.Context,
		node_cid Node_Cid_Field,
		node_expired_at Node_ExpiredAt_Field,
		node_amount Node_Amount_Field) (
		node *Node, err error)

	Create_Pin(ctx context.Context,
		pin_tx Pin_Tx_Field,
		pin_ix Pin_Ix_Field,
		pin_cid Pin_Cid_Field,
		pin_amount Pin_Amount_Field,
		optional Pin_Create_Fields) (
		pin *Pin, err error)

	Get_Pin_By_Cid(ctx context.Context,
		pin_cid Pin_Cid_Field) (
		pin *Pin, err error)

	Update_Node_By_Cid(ctx context.Context,
		node_cid Node_Cid_Field,
		update Node_Update_Fields) (
		node *Node, err error)

	Update_Pin_By_Tx_And_Ix(ctx context.Context,
		pin_tx Pin_Tx_Field,
		pin_ix Pin_Ix_Field,
		update Pin_Update_Fields) (
		pin *Pin, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() string
	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx tagsql.Tx) txMethods
	makeErr(err error) error
}

func openpgx(source string) (*sql.DB, error) {
	return sql.Open("pgx", source)
}
